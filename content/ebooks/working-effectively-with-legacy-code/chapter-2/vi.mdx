---
title: Working Effectively with Legacy Code
section: Part I - The Mechanics of Change
chapter: Chapter 2 - Working with Feedback
slug: working-effectively-with-legacy-code/chapter-2
date: 2025-01-17
locale: vi
type: child
id: 2
---

<HeadingLarge>Chapter 2: Làm việc với Phản hồi</HeadingLarge>

## Hai Cách Thay Đổi Phần Mềm

Thay đổi trong một hệ thống có thể được thực hiện theo hai cách chính. Tôi gọi chúng là *Chỉnh Sửa và Cầu Nguyện (Edit and Pray)* và *Kiểm Soát và Thay Đổi (Cover and Modify)*. Thật không may, *Chỉnh Sửa và Cầu Nguyện* gần như là tiêu chuẩn trong ngành công nghiệp phần mềm.

Khi bạn sử dụng *Chỉnh Sửa và Cầu Nguyện*, bạn cẩn thận lập kế hoạch cho những thay đổi mà bạn sẽ thực hiện, đảm bảo rằng bạn hiểu mã nguồn mà bạn sắp sửa đổi, và sau đó bắt đầu thực hiện những thay đổi đó. Khi hoàn thành, bạn chạy hệ thống để xem liệu thay đổi đã được áp dụng hay chưa, rồi tiếp tục kiểm tra thêm để đảm bảo rằng bạn không làm hỏng bất cứ thứ gì. Việc kiểm tra bổ sung này là điều thiết yếu. Khi thực hiện thay đổi, bạn hy vọng và cầu nguyện rằng mình sẽ làm đúng, đồng thời dành thêm thời gian để xác nhận điều đó.

Về mặt bề ngoài, *Chỉnh Sửa và Cầu Nguyện* dường như là “làm việc cẩn thận,” một điều rất chuyên nghiệp. Sự “cẩn thận” mà bạn áp dụng rõ ràng là điều tiên quyết, và bạn cẩn thận hơn nữa khi những thay đổi rất phức tạp vì có thể có nhiều điều xảy ra sai sót. Nhưng sự an toàn không chỉ là vấn đề về cẩn thận. Tôi không nghĩ rằng bất kỳ ai trong chúng ta sẽ chọn một bác sĩ phẫu thuật dùng dao phết bơ chỉ vì ông ấy làm việc cẩn thận. Việc thay đổi phần mềm hiệu quả, giống như phẫu thuật hiệu quả, thực sự đòi hỏi kỹ năng sâu sắc hơn. Làm việc cẩn thận sẽ không mang lại nhiều lợi ích nếu bạn không sử dụng đúng công cụ và kỹ thuật.

*Kiểm Soát và Thay Đổi* là một cách làm khác để thực hiện thay đổi. Ý tưởng đằng sau nó là có thể làm việc với một *mạng lưới an toàn* khi chúng ta thay đổi phần mềm. Mạng lưới an toàn này không phải là thứ mà chúng ta đặt dưới ghế để đỡ chúng ta nếu rơi khỏi ghế. Thay vào đó, nó giống như một chiếc áo choàng mà chúng ta phủ lên mã nguồn đang làm việc để đảm bảo rằng các thay đổi xấu không rò rỉ ra ngoài và ảnh hưởng đến phần còn lại của phần mềm. Kiểm soát phần mềm nghĩa là bao phủ nó bằng các bài kiểm tra. Khi chúng ta có một bộ kiểm tra tốt xung quanh một đoạn code, chúng ta có thể thực hiện thay đổi và nhanh chóng biết được liệu các tác động là tốt hay xấu. Chúng ta vẫn áp dụng cùng một mức độ cẩn thận, nhưng với phản hồi nhận được, chúng ta có thể thực hiện thay đổi một cách cẩn thận hơn.

Nếu bạn không quen thuộc với cách sử dụng kiểm tra này, tất cả điều này có thể nghe có vẻ hơi kỳ lạ. Theo truyền thống, các bài kiểm tra được viết và thực thi sau khi phát triển. Một nhóm lập trình viên viết code, và một nhóm kiểm tra chạy thử nghiệm trên code sau đó để xem nó có đáp ứng được các thông số kỹ thuật hay không. Trong một số đội phát triển rất truyền thống, đây là cách phần mềm được phát triển. Đội ngũ lập trình có thể nhận phản hồi, nhưng vòng phản hồi thường rất dài. Làm việc trong vài tuần hoặc vài tháng, rồi một nhóm khác sẽ cho bạn biết liệu bạn đã làm đúng hay chưa.

Kiểm tra được thực hiện theo cách này thực chất là “kiểm tra để cố gắng chứng minh tính đúng đắn.” Mặc dù đây là một mục tiêu tốt, nhưng các bài kiểm tra cũng có thể được sử dụng theo một cách rất khác: “kiểm tra để phát hiện thay đổi.”

Theo thuật ngữ truyền thống, điều này được gọi là kiểm tra hồi quy (regression testing). Chúng ta định kỳ chạy các bài kiểm tra để kiểm tra các hành vi đã được biết là đúng, nhằm phát hiện xem phần mềm của chúng ta có còn hoạt động như trước đây hay không.

Khi bạn có các bài kiểm tra xung quanh các khu vực mà bạn dự định thay đổi, chúng hoạt động như một cái kẹp phần mềm. Bạn có thể giữ nguyên hầu hết hành vi và biết rằng mình chỉ đang thay đổi những gì mình dự định.

<Callout><HeadingBase>Software Vise</HeadingBase><div>**vise** (n.). Một thiết bị kẹp, thường bao gồm hai hàm được đóng hoặc mở bằng một con vít hoặc đòn bẩy, được sử dụng trong nghề mộc hoặc gia công kim loại để giữ chặt một vật ở vị trí. *The American Heritage Dictionary of the English Language, Fourth Edition*.</div><div>Khi chúng ta có các bài kiểm tra phát hiện thay đổi, nó giống như đặt một cái vise quanh code của chúng ta. Hành vi của code được giữ cố định. Khi thực hiện thay đổi, chúng ta có thể biết rằng mình chỉ đang thay đổi một phần nhỏ hành vi tại một thời điểm. Tóm lại, chúng ta kiểm soát được công việc của mình.</div></Callout>

Regression testing là một ý tưởng tuyệt vời. Vậy tại sao mọi người không thực hiện nó thường xuyên hơn? Có một vấn đề nhỏ với regression testing. Thông thường, khi thực hành regression testing, nó được thực hiện ở giao diện ứng dụng. Dù đó là ứng dụng web, giao diện dòng lệnh (CLI), hay ứng dụng giao diện đồ họa (GUI), regression testing truyền thống thường được coi là một kiểu kiểm thử ở cấp độ giao diện ứng dụng. Điều này thật đáng tiếc. Phản hồi mà chúng ta nhận được từ regression testing rất hữu ích và xứng đáng được thực hiện ở mức chi tiết hơn.

Hãy làm một thí nghiệm tư duy. Chúng ta đang bước vào một hàm lớn chứa một lượng logic phức tạp. Chúng ta phân tích, suy nghĩ, trò chuyện với những người hiểu biết nhiều hơn về đoạn code này so với chúng ta, và sau đó chúng ta thực hiện thay đổi. Chúng ta muốn đảm bảo rằng thay đổi này không làm hỏng bất kỳ thứ gì, nhưng làm thế nào để thực hiện điều đó? May mắn thay, chúng ta có một nhóm kiểm soát chất lượng (QA) sở hữu một bộ regression testing có thể chạy qua đêm. Chúng ta gọi điện yêu cầu họ sắp xếp chạy kiểm thử, và họ trả lời rằng, vâng, họ có thể chạy các bài kiểm tra qua đêm. Thật may mắn vì chúng ta đã gọi sớm, vì các nhóm khác thường cố gắng đặt lịch regression testing vào giữa tuần. Nếu chúng ta chậm trễ hơn nữa, có thể không còn khung thời gian hoặc máy móc khả dụng.

Chúng ta thở phào nhẹ nhõm và quay trở lại công việc. Còn khoảng năm thay đổi khác tương tự như thay đổi vừa thực hiện, tất cả đều nằm trong các khu vực phức tạp tương đương. Và chúng ta không làm việc một mình. Chúng ta biết rằng còn một số người khác cũng đang thực hiện thay đổi.

Sáng hôm sau, chúng ta nhận được một cuộc gọi. Daiva từ nhóm kiểm thử thông báo rằng các bài kiểm tra AE1021 và AE1029 đã thất bại qua đêm. Cô ấy không chắc liệu đó có phải là do thay đổi của chúng ta hay không, nhưng cô ấy gọi vì biết rằng chúng ta sẽ xử lý vấn đề này giúp cô ấy. Chúng ta bắt đầu gỡ lỗi để xác định xem lỗi là do một trong những thay đổi của chúng ta hay từ những người khác.

Điều này nghe có thực tế không? Đáng buồn thay, nó rất thực tế.

Hãy xem xét một kịch bản khác

Chúng ta cần thực hiện một thay đổi đối với một hàm khá dài và phức tạp. May mắn thay, chúng ta phát hiện một bộ kiểm thử đơn vị (unit tests) đã được viết sẵn cho nó. Những người làm việc với đoạn code này trước đó đã viết khoảng 20 bài unit tests, kiểm tra kỹ càng chức năng của nó. Chúng ta chạy các bài kiểm thử này và nhận thấy tất cả đều thành công. Tiếp theo, chúng ta xem qua các bài kiểm thử để hiểu rõ hơn về hành vi thực tế của đoạn code.

Chúng ta chuẩn bị thực hiện thay đổi, nhưng nhận ra rằng rất khó để tìm ra cách thay đổi nó. Đoạn code không rõ ràng, và chúng ta thực sự muốn hiểu rõ hơn về nó trước khi tiến hành thay đổi. Các bài kiểm thử sẽ không bắt được mọi thứ, vì vậy chúng ta muốn làm cho đoạn code trở nên rõ ràng hơn để có thêm tự tin khi thực hiện thay đổi. Bên cạnh đó, chúng ta cũng không muốn bản thân hoặc bất kỳ ai khác phải trải qua quá trình khó khăn như chúng ta để cố gắng hiểu đoạn code này. Thật lãng phí thời gian!

Chúng ta bắt đầu cải tiến (refactor) đoạn code một chút. Chúng ta tách một số phương thức và di chuyển một số logic điều kiện. Sau mỗi thay đổi nhỏ, chúng ta chạy bộ kiểm thử đơn vị (unit test) nhỏ của mình. Hầu như mỗi lần chạy, các bài kiểm thử đều thành công. Vài phút trước, chúng ta đã mắc lỗi khi đảo ngược logic của một điều kiện, nhưng nhờ có bài kiểm thử thất bại, chúng ta đã phục hồi chỉ trong vòng một phút. Khi hoàn thành việc cải tiến, đoạn code trở nên rõ ràng hơn rất nhiều. Chúng ta thực hiện thay đổi mà mình định làm và tự tin rằng nó đúng. Chúng ta cũng bổ sung thêm một vài bài kiểm thử để xác nhận hành vi mới. Những lập trình viên tiếp theo làm việc với đoạn code này sẽ dễ dàng hơn rất nhiều và có các bài kiểm thử bao phủ chức năng của nó.

Bạn muốn nhận phản hồi trong một phút hay qua đêm? Tình huống nào hiệu quả hơn?

Unit testing là một trong những thành phần quan trọng nhất khi làm việc với mã nguồn cũ (legacy code). Các bài regression tests ở cấp độ hệ thống là tuyệt vời, nhưng các bài kiểm thử nhỏ, cục bộ là vô giá. Chúng có thể cung cấp phản hồi khi bạn đang phát triển và cho phép bạn cải tiến code một cách an toàn hơn nhiều.

## Unit Testing là gì??

Thuật ngữ *unit test* đã có lịch sử lâu đời trong phát triển phần mềm. Điểm chung của hầu hết các định nghĩa về unit test là ý tưởng rằng đây là các bài kiểm thử độc lập, thực hiện trên components riêng lẻ của phần mềm. Vậy components là gì? Định nghĩa này có thể khác nhau, nhưng trong unit test, chúng ta thường quan tâm đến các đơn vị hành vi nhỏ nhất trong hệ thống. Trong mã lệnh theo kiểu thủ tục (procedural code), các đơn vị thường là các hàm. Trong mã hướng đối tượng (object-oriented code), các đơn vị là các lớp (classes).

<Callout><HeadingBase>Test Harnesses</HeadingBase><div>Trong cuốn sách này, tôi sử dụng thuật ngữ *khung kiểm thử (test harness)* như một thuật ngữ tổng quát để chỉ code kiểm thử mà chúng ta viết nhằm kiểm tra một phần mềm và code cần thiết để chạy các kiểm thử đó. Chúng ta có thể sử dụng nhiều loại khung kiểm thử khác nhau để làm việc với code của mình. Trong Chương 5, *Công cụ (Tools)*, tôi sẽ thảo luận về framework kiểm thử xUnit và framework FIT. Cả hai đều có thể được sử dụng để thực hiện các kiểm thử được mô tả trong cuốn sách này.</div></Callout>

Liệu chúng ta có thể kiểm thử chỉ một hàm hoặc một class không? Trong các hệ thống thủ tục, thường rất khó để kiểm thử các hàm một cách độc lập. Các hàm cấp cao gọi các hàm khác, rồi những hàm này lại gọi các hàm khác, và cứ tiếp diễn cho đến mức thấp nhất là cấp độ máy. Trong các hệ thống hướng đối tượng, việc kiểm thử các class một cách độc lập có phần dễ dàng hơn, nhưng thực tế là, các class thường không sống độc lập. Hãy nghĩ về tất cả các class mà bạn từng viết nhưng không sử dụng bất kỳ class nào khác. Chúng khá hiếm, phải không? Thông thường chúng là các class dữ liệu nhỏ hoặc các class cấu trúc dữ liệu như stack và queue (thậm chí những class này cũng có thể sử dụng các class khác).

Kiểm thử trong sự cô lập là một phần quan trọng của định nghĩa kiểm thử đơn vị (unit test), nhưng tại sao nó lại quan trọng? Sau cùng, rất nhiều lỗi xảy ra khi các thành phần phần mềm được tích hợp. Chẳng phải các bài kiểm thử lớn bao quát các vùng chức năng rộng của code sẽ quan trọng hơn sao? Thực ra, chúng rất quan trọng, tôi không phủ nhận điều đó, nhưng có một vài vấn đề với các bài kiểm thử lớn:

- **Định vị lỗi—** Khi các bài kiểm thử ngày càng xa rời thành phần mà chúng kiểm thử, việc xác định ý nghĩa của một lỗi kiểm thử trở nên khó khăn hơn. Thường phải mất khá nhiều công sức để xác định chính xác nguồn gốc của lỗi kiểm thử. Bạn phải xem xét đầu vào của kiểm thử, lỗi xảy ra, và xác định vị trí trên đường dẫn từ đầu vào đến đầu ra nơi lỗi xảy ra. Đúng là chúng ta cũng phải làm điều đó với các unit tests, nhưng thường công việc này khá đơn giản.
- **Thời gian thực thi—** Các kiểm thử lớn thường mất nhiều thời gian hơn để thực thi. Điều này có thể khiến quá trình chạy kiểm thử trở nên khá khó chịu. Các kiểm thử mất quá nhiều thời gian để chạy thường bị bỏ qua.
- **Độ bao phủ—** Rất khó để thấy mối liên hệ giữa một đoạn code và các giá trị được sử dụng để kiểm tra nó. Chúng ta thường có thể tìm hiểu liệu một đoạn code có được kiểm tra bởi một bài kiểm thử hay không bằng cách sử dụng các công cụ đo độ phủ, nhưng khi chúng ta thêm code mới, có thể cần nhiều công sức để tạo ra các bài kiểm thử cấp cao để kiểm tra code mới này.

<Callout>Một trong những điều gây khó chịu nhất về các bài kiểm thử lớn là khả năng định vị lỗi (error localization) có thể đạt được nếu chúng ta chạy kiểm thử thường xuyên hơn, nhưng việc này rất khó để thực hiện. Nếu chúng ta chạy kiểm thử và tất cả đều vượt qua, sau đó thực hiện một thay đổi nhỏ và kiểm thử thất bại, chúng ta sẽ biết chính xác vấn đề xảy ra ở đâu. Vấn đề được kích hoạt từ thay đổi nhỏ cuối cùng mà chúng ta vừa thực hiện. Lúc đó, chúng ta có thể quay lại thay đổi đó và thử lại. Nhưng nếu kiểm thử của chúng ta lớn, thời gian thực thi có thể quá dài, và xu hướng sẽ là tránh chạy kiểm thử đủ thường xuyên để thực sự định vị lỗi.</Callout>

Unit tests lấp đầy những khoảng trống mà kiểm thử lớn không thể làm được. Chúng ta có thể kiểm tra các đoạn code một cách độc lập; có thể nhóm các bài kiểm thử để chạy chúng trong một số điều kiện cụ thể hoặc trong những điều kiện khác nhau. Với unit tests, chúng ta có thể định vị lỗi nhanh chóng. Nếu chúng ta nghĩ rằng có lỗi trong một đoạn code cụ thể và có thể sử dụng nó trong một khung kiểm thử (test harness), thường chúng ta có thể viết code kiểm thử nhanh chóng để kiểm tra xem lỗi thực sự có tồn tại hay không.

Dưới đây là các đặc điểm của một bài unit tests tốt:

1. Chúng chạy nhanh.
2. Chúng giúp chúng ta định vị vấn đề.

Trong ngành này, mọi người thường tranh luận qua lại về việc liệu một kiểm thử cụ thể có phải là unit tests hay không. Liệu một bài kiểm thử có thực sự là unit tests nếu nó sử dụng một production class khác? Tôi quay lại hai đặc điểm trên: Bài kiểm thử có chạy nhanh không? Nó có giúp định vị lỗi nhanh chóng không? Tất nhiên, có một sự liên tục giữa các bài kiểm thử. Một số kiểm thử lớn hơn và sử dụng nhiều class cùng nhau. Thực tế, chúng có thể giống như các bài kiểm thử tích hợp nhỏ. Tự chúng có vẻ chạy nhanh, nhưng điều gì xảy ra khi bạn chạy tất cả chúng cùng lúc? Khi bạn có một bài kiểm thử thực thi một class cùng với nhiều cộng tác viên của nó, bài kiểm thử có xu hướng phát triển. Nếu bạn chưa dành thời gian để làm cho class có thể khởi tạo độc lập trong một khung kiểm thử, thì việc thêm code mới sẽ dễ dàng đến mức nào? Nó không bao giờ dễ hơn. Mọi người thường trì hoãn việc này. Theo thời gian, bài kiểm thử có thể mất tới 1/10 giây để thực thi.

<Callout>Một unit test mất 1/10 giây để chạy là một unit test chậm.</Callout>

Vâng, tôi nói nghiêm túc đấy. Vào thời điểm tôi viết điều này, 1/10 giây là một khoảng thời gian rất dài đối với một bài kiểm thử đơn vị. Hãy làm một phép tính. Nếu bạn có một dự án với 3.000 classes và mỗi class có khoảng 10 bài kiểm thử, thì sẽ có tổng cộng 30.000 bài kiểm thử. Mất bao lâu để chạy tất cả các bài kiểm thử cho dự án đó nếu mỗi bài kiểm thử mất 1/10 giây? Gần một giờ đồng hồ. Đó là khoảng thời gian quá dài để chờ phản hồi. Bạn không có 3.000 classes? Cắt giảm một nửa đi. Nhưng vẫn mất đến nửa giờ. Mặt khác, nếu các bài kiểm thử chỉ mất 1/100 giây mỗi bài? Lúc này chúng ta đang nói đến khoảng 5 đến 10 phút. Với thời gian đó, tôi có thể sử dụng một tập hợp con để làm việc, nhưng tôi không ngại chạy tất cả chúng mỗi vài giờ.

Với sự giúp đỡ của Định luật Moore, tôi hy vọng sẽ thấy phản hồi kiểm thử gần như tức thì ngay cả với các hệ thống lớn nhất trong suốt cuộc đời mình. Tôi nghi ngờ rằng làm việc trong những hệ thống đó sẽ giống như làm việc với mã nguồn có thể “phản đòn”. Nó sẽ có khả năng cho chúng ta biết khi nào nó bị thay đổi theo cách không đúng.

<Callout>
Unit tests phải chạy nhanh. Nếu chúng không chạy nhanh, chúng không phải là unit tests.

Có những loại kiểm thử khác thường bị nhầm lẫn là unit tests. Một bài kiểm thử không phải là unit tests nếu:

1. Nó tương tác với cơ sở dữ liệu.
2. Nó giao tiếp qua mạng.
3. Nó truy cập hệ thống tệp.
4. Bạn phải thực hiện các thay đổi đặc biệt lên môi trường (chẳng hạn như chỉnh sửa tệp cấu hình) để chạy nó.

Các bài kiểm thử làm những việc này không phải là xấu. Chúng thường đáng để viết, và thông thường bạn sẽ viết chúng trong khung kiểm thử đơn vị (unit test harnesses). Tuy nhiên, điều quan trọng là có thể tách biệt chúng khỏi các unit tests thực sự để bạn có thể giữ một tập hợp các bài kiểm thử mà bạn có thể chạy nhanh bất cứ khi nào bạn thực hiện thay đổi.
</Callout>

## Higher-Level Testing

Unit tests rất tuyệt, nhưng vẫn có chỗ cho các bài kiểm thử cấp cao hơn, các bài kiểm thử bao quát các kịch bản và tương tác trong một ứng dụng. Kiểm thử cấp cao có thể được sử dụng để cố định hành vi của một tập hợp các class cùng một lúc. Khi làm được điều đó, bạn thường có thể viết các bài kiểm thử cho từng class dễ dàng hơn.

## Test Coverings

Vậy làm thế nào để chúng ta bắt đầu thực hiện thay đổi trong một dự án legacy? Điều đầu tiên cần lưu ý là, nếu có lựa chọn, luôn luôn an toàn hơn khi có các bài kiểm thử xung quanh các thay đổi mà chúng ta thực hiện. Khi thay đổi code, chúng ta có thể gây ra lỗi; dù sao thì chúng ta cũng là con người. Nhưng khi chúng ta bao phủ code của mình bằng các bài kiểm thử trước khi thay đổi, chúng ta sẽ có nhiều khả năng bắt được bất kỳ lỗi nào mà mình tạo ra.

Hình 2.1 minh họa một tập hợp nhỏ các class. Chúng ta muốn thực hiện thay đổi trong phương thức `getResponseText` của `InvoiceUpdateResponder` và phương thức `getValue` của `Invoice`. Những phương thức đó là các điểm thay đổi của chúng ta. Chúng ta có thể bao phủ chúng bằng cách viết các bài kiểm thử cho các class mà chúng đang thuộc về.

Để viết và chạy các bài kiểm thử, chúng ta phải có khả năng tạo các thực thể của `InvoiceUpdateResponder` và `Invoice` trong một khung kiểm thử. Chúng ta có thể làm điều đó không? Có vẻ như việc tạo một `Invoice` khá đơn giản; nó có một constructor không yêu cầu bất kỳ đối số nào. Tuy nhiên, `InvoiceUpdateResponder` có thể là một thách thức. Nó chấp nhận một `DBConnection`, một kết nối thực tới một cơ sở dữ liệu đang hoạt động. Làm thế nào để chúng ta xử lý điều đó trong một bài kiểm thử? Chúng ta có phải thiết lập một cơ sở dữ liệu với dữ liệu cho các bài kiểm thử của mình không? Đó là rất nhiều công việc. Chẳng phải việc kiểm thử qua cơ sở dữ liệu sẽ rất chậm sao? Hiện tại, chúng ta cũng không quan tâm nhiều đến cơ sở dữ liệu; chúng ta chỉ muốn bao phủ các thay đổi trong `InvoiceUpdateResponder` và `Invoice`.

Chúng ta cũng có một vấn đề lớn hơn. Constructor của `InvoiceUpdateResponder` cần một `InvoiceUpdateServlet` làm tham số. Liệu việc tạo một thực thể của `InvoiceUpdateServlet` có dễ dàng không? Chúng ta có thể thay đổi code để nó không cần servlet đó nữa. Nếu `InvoiceUpdateResponder` chỉ cần một ít thông tin từ `InvoiceUpdateServlet`, chúng ta có thể truyền thông tin đó thay vì truyền toàn bộ servlet vào, nhưng chẳng phải chúng ta nên có một bài kiểm thử để đảm bảo rằng mình đã thực hiện thay đổi đó đúng cách hay sao?

<IllustrationImage src="/assets/images/ebooks/working-effectively-with-legacy-code/figure-2-1.png" alt="Invoice update classes." label="Figure 2.1" size="lg" sizeDialog="lg">Invoice update classes.</IllustrationImage>

Tất cả những vấn đề này đều là vấn đề về phụ thuộc. Khi các class phụ thuộc trực tiếp vào những thứ khó sử dụng trong bài kiểm thử, chúng sẽ trở nên khó chỉnh sửa và khó làm việc cùng.

<Callout>Phụ thuộc (Dependency) là một trong những vấn đề quan trọng nhất trong phát triển phần mềm. Phần lớn công việc liên quan đến legacy code đều xoay quanh việc phá vỡ các phụ thuộc để việc thay đổi trở nên dễ dàng hơn.</Callout>

Vậy làm thế nào để chúng ta làm điều đó? Làm thế nào để chúng ta thiết lập các bài kiểm thử mà không cần thay đổi code? Thực tế đáng buồn là, trong nhiều trường hợp, điều đó không thực sự khả thi. Trong một số trường hợp, điều đó thậm chí là không thể. Trong ví dụ vừa xem, chúng ta có thể cố gắng vượt qua vấn đề `DBConnection` bằng cách sử dụng một cơ sở dữ liệu thực, nhưng còn vấn đề về servlet thì sao? Chúng ta có phải tạo ra một servlet hoàn chỉnh và truyền nó vào constructor của `InvoiceUpdateResponder` không? Chúng ta có thể đưa nó vào trạng thái đúng không? Điều đó có thể là khả thi. Nhưng chúng ta sẽ làm gì nếu chúng ta đang làm việc với một ứng dụng giao diện đồ họa (GUI) trên máy tính để bàn? Có thể chúng ta không có bất kỳ giao diện lập trình nào. Logic có thể bị gắn chặt vào các class GUI. Vậy chúng ta làm gì khi đó?

<Callout><HeadingBase>Nghịch Lý Của Legacy Code</HeadingBase><div>Khi chúng ta thay đổi code, chúng ta nên có các thử nghiệm tại chỗ. Nhưng để thực hiện các thử nghiệm, chúng ta thường phải thay đổi code.</div></Callout>

Trong ví dụ về Invoice, chúng ta có thể thử kiểm thử ở mức cao hơn. Nếu khó viết bài kiểm thử mà không thay đổi một class cụ thể, đôi khi kiểm thử một class sử dụng nó sẽ dễ dàng hơn; dù thế nào đi nữa, chúng ta thường phải phá vỡ các phụ thuộc giữa các class ở một điểm nào đó. Trong trường hợp này, chúng ta có thể phá vỡ phụ thuộc vào `InvoiceUpdateServlet` bằng cách chỉ truyền điều mà `InvoiceUpdateResponder` thực sự cần. Nó cần tập hợp các ID hóa đơn mà `InvoiceUpdateServlet` đang giữ. Chúng ta cũng có thể phá vỡ phụ thuộc mà `InvoiceUpdateResponder` có với `DBConnection` bằng cách ra mắt một interface (`IDBConnection`) và thay đổi `InvoiceUpdateResponder` để nó sử dụng interface thay vì phụ thuộc trực tiếp vào `DBConnection`. Hình 2.2 minh họa trạng thái của các class này sau khi thực hiện các thay đổi.

<IllustrationImage src="/assets/images/ebooks/working-effectively-with-legacy-code/figure-2-2.png" alt="Invoice update classes." label="Figure 2.2" size="lg" sizeDialog="lg">Invoice update classes with dependencies broken.</IllustrationImage>

Liệu việc thực hiện các refactoring này mà không có bài kiểm thử có an toàn không? Có thể. Các refactoring này được gọi lần lượt là *Primitivize Parameter (385)* và *Extract Interface (362)*. Chúng được mô tả trong danh mục các kỹ thuật phá vỡ phụ thuộc ở cuối cuốn sách. Khi chúng ta phá vỡ các phụ thuộc, chúng ta thường có thể viết các bài kiểm thử giúp việc thay đổi xâm lấn trở nên an toàn hơn. Bí quyết là thực hiện các refactoring ban đầu này một cách rất thận trọng.

Việc thận trọng là điều đúng đắn khi chúng ta có khả năng gây ra lỗi, nhưng đôi khi khi chúng ta phá vỡ các phụ thuộc để bao phủ code, kết quả không đẹp như trong ví dụ trước đó. Chúng ta có thể thêm các tham số vào phương thức mà không thực sự cần thiết trong production code, hoặc chúng ta có thể tách các class theo cách kỳ lạ chỉ để có thể viết bài kiểm thử. Khi làm vậy, chúng ta có thể khiến code trong khu vực đó trở nên kém đẹp hơn. Nếu bớt thận trọng hơn, chúng ta sẽ sửa chữa nó ngay lập tức. Chúng ta có thể làm điều đó, nhưng nó phụ thuộc vào mức độ rủi ro liên quan. Khi lỗi là một vấn đề lớn, và thường là như vậy, thì việc thận trọng là đáng giá.

<Callout>
Khi phá vỡ các phụ thuộc trong legacy code, bạn thường phải tạm gác lại ý thức thẩm mỹ của mình. Một số phụ thuộc được phá vỡ một cách sạch sẽ; những phụ thuộc khác trông sẽ kém lý tưởng hơn từ góc độ thiết kế. Chúng giống như các vết cắt trong phẫu thuật: Có thể sẽ để lại một vết sẹo trong code của bạn sau khi làm việc, nhưng mọi thứ bên dưới có thể trở nên tốt hơn.

Nếu sau này bạn có thể bao phủ code xung quanh điểm mà bạn đã phá vỡ các phụ thuộc, bạn cũng có thể chữa lành vết sẹo đó.
</Callout>

## Thuật Toán Thay Đổi Legacy Code

Khi bạn cần thực hiện thay đổi trong một mã nguồn legacy, đây là một thuật toán bạn có thể sử dụng:

1. Xác định điểm cần thay đổi.
2. Tìm điểm để kiểm thử.
3. Phá vỡ các phụ thuộc.
4. Viết các bài kiểm thử.
5. Thực hiện thay đổi và tái cấu trúc.

Mục tiêu hàng ngày khi làm việc với legacy code không chỉ là thực hiện bất kỳ thay đổi nào. Chúng ta muốn thực hiện những thay đổi chức năng mang lại giá trị, đồng thời đưa nhiều phần của hệ thống vào trạng thái được kiểm thử hơn. Kết thúc mỗi giai đoạn lập trình, chúng ta không chỉ nên có đoạn code cung cấp tính năng mới mà còn có các bài kiểm thử cho nó. Theo thời gian, những khu vực code được kiểm thử sẽ nổi lên như những hòn đảo giữa đại dương. Làm việc trong những hòn đảo này sẽ trở nên dễ dàng hơn. Dần dần, các hòn đảo sẽ kết hợp thành những lục địa. Cuối cùng, bạn sẽ làm việc trong những "lục địa" code được bao phủ bởi các bài kiểm thử.

Hãy cùng xem qua từng bước và cách cuốn sách này sẽ hỗ trợ bạn.

### Xác Định Điểm Cần Thay Đổi

Những nơi bạn cần thay đổi phụ thuộc nhiều vào kiến trúc của bạn. Nếu bạn không hiểu rõ thiết kế để cảm thấy rằng bạn đang thay đổi ở đúng chỗ, hãy xem qua Chương 16, *Tôi Không Hiểu Mã Đủ Để Thay Đổi Nó*, và Chương 17, *Ứng Dụng Của Tôi Không Có Cấu Trúc*.

### Tìm Điểm Để Kiểm Thử

Trong một số trường hợp, việc tìm điểm để viết bài kiểm thử rất dễ dàng, nhưng trong legacy code, điều này thường rất khó. Hãy tham khảo Chương 11, *Tôi Cần Thực Hiện Một Thay Đổi. Tôi Nên Kiểm Thử Những Phương Thức Nào?*, và Chương 12, *Tôi Cần Thực Hiện Nhiều Thay Đổi Trong Một Khu Vực. Tôi Có Cần Phá Vỡ Các Phụ Thuộc Cho Tất Cả Các Lớp Liên Quan Không?* Các chương này cung cấp các kỹ thuật giúp bạn xác định nơi cần viết bài kiểm thử cho những thay đổi cụ thể.

### Phá Vỡ Các Phụ Thuộc

Phụ thuộc thường là rào cản rõ ràng nhất đối với việc kiểm thử. Vấn đề này thường xuất hiện dưới hai dạng: khó khởi tạo đối tượng trong test harness và khó chạy các phương thức trong test harness. Trong legacy code, bạn thường phải phá vỡ các phụ thuộc để có thể thiết lập kiểm thử. Lý tưởng nhất là chúng ta sẽ có các bài kiểm thử để xác định liệu những thay đổi khi phá vỡ phụ thuộc có gây ra vấn đề hay không, nhưng thường thì chúng ta không có. Hãy xem Chương 23, *Làm Sao Tôi Biết Mình Không Phá Hỏng Bất Cứ Điều Gì?*, để biết một số phương pháp có thể giúp bạn thực hiện những bước đầu tiên an toàn hơn khi đưa hệ thống vào trạng thái kiểm thử. Sau khi thực hiện điều này, hãy tham khảo Chương 9, *Tôi Không Thể Đưa Lớp Này Vào Test Harness*, và Chương 10, *Tôi Không Thể Chạy Phương Thức Này Trong Test Harness*, để biết cách vượt qua những vấn đề phụ thuộc phổ biến. Các chương này tham chiếu nhiều đến danh mục các kỹ thuật phá vỡ phụ thuộc ở phần cuối sách, nhưng không bao gồm tất cả các kỹ thuật. Hãy dành thời gian xem qua danh mục để tìm thêm ý tưởng về cách phá vỡ phụ thuộc.

Phụ thuộc cũng xuất hiện khi chúng ta có ý tưởng về một bài kiểm thử nhưng không thể dễ dàng viết nó. Nếu bạn thấy không thể viết các bài kiểm thử do phụ thuộc trong các phương thức lớn, hãy xem Chương 22, *Tôi Cần Thay Đổi Một Phương Thức Quái Vật Và Tôi Không Thể Viết Bài Kiểm Thử Cho Nó*. Nếu bạn thấy có thể phá vỡ phụ thuộc nhưng mất quá nhiều thời gian để xây dựng kiểm thử, hãy tham khảo Chương 7, *Thay Đổi Một Chút Mất Cả Đời*. Chương đó mô tả thêm các công việc phá vỡ phụ thuộc mà bạn có thể thực hiện để giảm thời gian xây dựng trung bình.

### Viết Bài Kiểm Thử

Tôi nhận thấy rằng các bài kiểm thử tôi viết trong legacy code hơi khác so với các bài kiểm thử tôi viết cho code mới. Hãy xem Chương 13, *Tôi Cần Thực Hiện Một Thay Đổi Nhưng Không Biết Viết Bài Kiểm Thử Nào*, để tìm hiểu thêm về vai trò của các bài kiểm thử trong công việc với legacy code.

### Thực Hiện Thay Đổi và Tái Cấu Trúc

Tôi khuyến khích sử dụng phát triển hướng kiểm thử (TDD) để thêm các tính năng trong legacy code. Chương 8, *Làm Sao Tôi Thêm Một Tính Năng?*, mô tả về TDD và một số kỹ thuật bổ sung tính năng khác. Sau khi thực hiện thay đổi trong legacy code, chúng ta thường hiểu rõ hơn về các vấn đề của nó, và các bài kiểm thử chúng ta đã viết để thêm tính năng thường cung cấp cho chúng ta sự bảo vệ để thực hiện tái cấu trúc. Chương 20, *Class Này Quá Lớn Và Tôi Không Muốn Nó Trở Nên Lớn Hơn*; Chương 22, *Tôi Cần Thay Đổi Một Phương Thức Quái Vật Và Tôi Không Thể Viết Bài Kiểm Thử Cho Nó*; và Chương 21, *Tôi Phải Thay Đổi Cùng Một Code Ở Nhiều Nơi Khác Nhau* cung cấp nhiều kỹ thuật bạn có thể sử dụng để bắt đầu đưa legacy code của mình hướng đến cấu trúc tốt hơn. Hãy nhớ rằng những điều được mô tả trong các chương này chỉ là “những bước đi nhỏ.” Chúng không chỉ cho bạn cách để làm cho thiết kế trở nên lý tưởng, clean hoặc pattern-enriched. Có nhiều cuốn sách khác chỉ bạn cách làm điều đó, và khi có cơ hội sử dụng những kỹ thuật đó, tôi khuyến khích bạn làm như vậy. Các chương này chỉ cho bạn cách cải thiện thiết kế, nơi “cải thiện” phụ thuộc vào ngữ cảnh và thường chỉ đơn giản là giúp thiết kế dễ bảo trì hơn so với trước đây một chút. Nhưng đừng coi nhẹ công việc này. Thường thì những điều đơn giản nhất, như chia nhỏ một class lớn chỉ để dễ làm việc hơn, có thể tạo ra sự khác biệt lớn trong ứng dụng, mặc dù có phần máy móc.

### Phần Còn Lại Của Cuốn Sách

Phần còn lại của cuốn sách sẽ chỉ bạn cách thực hiện các thay đổi trong legacy code. Hai chương tiếp theo chứa tài liệu nền tảng về ba khái niệm quan trọng trong công việc với legacy code: cảm nhận, phân tách và đường may (seams).
